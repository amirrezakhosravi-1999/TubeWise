TubeWise: MVP & Early Growth Product
Specification
Product Overview
TubeWise is a YouTube learning and content generation web app (with com￾panion Chrome extension) that helps users quickly digest video content and
generate new content from it. The MVP will support desktop, mobile, and
tablet responsive views. All Pro features are included at launch. Key features
include:
• AI Summaries w/ Timestamps: Auto-generated concise summaries
of YouTube videos with timestamped key points
• Chrome Extension (Sidebar & Chat): A browser extension that adds
a sidebar on YouTube for on-page chat, transcript navigation, and quick
video summarization.
• Multi-Video Comparison: Ability to input multiple video URLs and
get a comprehensive comparative analysis or combined summary.
• Fact-Checking Assistant: An AI assistant (powered by Perplexity’s
API) to fact-check video claims with cited sources
• Content Generation: One-click generation of derivative content (Twit￾ter threads, LinkedIn posts, Notion summaries) from video insights.
• Smart Research Assistant: Automatically analyze top videos on a
given topic (find top relevant videos and summarize key insights across
them).
• Personal Dashboard: User dashboard to save highlights, organize sum￾maries by category/topic, and export data.
• Admin & Analytics: Admin dashboard for user management (assign
credits, roles) and monitoring usage, plus integration of analytics (PostHog/Plausible)
and email notifications (MailerSend/Resend).
• Internationalization (i18n): UI supports English, Spanish, Portuguese
from v1, with easy expansion to other languages.
1
Responsibilities, Tools, and Deliverables by Team
Role
Full-Stack Developer (Web Platform & Backend)
Responsibilities:
• End-to-End Feature Development: Implement all core features on
the web app – from front-end UI to backend logic – including video sum￾marization display, multi-URL comparison interface, content generation
outputs, and the personal dashboard. Ensure responsive design on desk￾top, mobile, and tablet for all pages.
• API & Backend Logic: Develop robust backend endpoints (REST or
GraphQL) to handle requests: e.g. fetching YouTube transcripts, interact￾ing with LLMs for summaries, invoking Perplexity API for fact-checking,
and exporting content. Incorporate logic to enforce usage limits (e.g. 5
videos/month free, Pro limits) and handle user requests in parallel.
• User Authentication & Payments: Set up secure user auth (email/password
and OAuth options) and integrate subscription payments for Pro tier (e.g.
via Stripe). Ensure that Free vs Pro features are gated correctly (e.g. limit
“comprehensive reviews” to 10/month for Pro, block beyond 5 videos for
Free).
• Database & Models: Design the database schema for users, videos
analyzed, summaries, saved highlights, etc. Include tables for user pro￾files (with language preference, role, credits), usage counts, saved content
(highlights, exports), and admin-assigned credits. Use a relational DB
(PostgreSQL for reliability and consistency) for structured data (users,
subscriptions, content) and possibly a lightweight NoSQL or in-memory
store for caching transcripts or intermediate LLM results.
• Admin Dashboard: Build an internal admin interface (web page or
separate admin app section) for admins to manage users and monitor
activity. Features: view user list with their plan/usage, manually adjust
credits or assign Pro access, view system logs, and moderate content if
needed. This can be a simple CRUD interface protected for admin roles.
• Analytics Integration: Instrument the application with event tracking
for user actions (sign-ups, video summaries generated, content exported,
etc.). Use an analytics platform like PostHog (preferred for its self-hosting
and advanced product analytics) or Plausible for privacy-friendly web
stats. Ensure key metrics (conversion funnel from Free→Pro, feature us￾age frequency) are collected.
• Email Notifications: Integrate a transactional email service (e.g. Mail￾erSend for simplicity and deliverability) to send automated emails: wel￾come emails, password resets, usage summaries, and upgrade prompts.
2
Set up email templates for various triggers (e.g. “You have 1 video credit
left” for free users, “Your summary is ready” notifications, etc.).
• Internationalization Support: Implement an i18n library/framework
to support multiple languages in the UI from day one. Externalize all
user-facing strings into translation files (for EN, ES, PT in v1). Ensure
locale can be selected or auto-detected, and that formatting (dates, etc.)
adjusts per locale.
• Scalability & Infrastructure: Make architecture decisions that allow
the product to scale smoothly as usage grows. Use a robust web framework
(e.g. Next.js with React) to enable rapid development and SSR, which
also can scale easily as the project grows. Leverage Next.js API routes
(or a Node.js/NestJS backend) for server-side logic, deployed as serverless
functions or containerized microservices. Host on a scalable platform (e.g.
Vercel for ease of Next.js deployment with automatic scaling, or Docker
containers on AWS). Ensure the backend is stateless (store session info in
HTTP-only cookies or JWTs) so horizontal scaling is easy. Use connection
pooling for the database (e.g. via a service like Supabase or PgBouncer)
to handle many concurrent requests.
• Performance & Rate Limiting: Implement caching and rate-limiting
as needed. For example, cache YouTube transcripts and analysis results
in memory or a Redis cache to avoid repeated heavy calls for the same
video. Use a rate limiting library or middleware to prevent abuse of the
API (especially for the free tier or the fact-checking queries). Plan for
background job processing for long-running tasks: e.g., if analyzing mul￾tiple long videos, consider offloading to a task queue (BullMQ or Redis
queue) and returning results asynchronously (with polling or WebSocket
notifications to the client).
• Security & Compliance: Ensure secure coding practices: sanitize in￾puts (especially for any content embedded from YouTube transcripts), use
HTTPS everywhere, and secure API keys (for LLMs, YouTube, etc.) in
backend. Comply with YouTube API terms if using their data. Imple￾ment basic GDPR compliance for user data (allow deletion of account,
etc.), and prepare infrastructure for scaling user data securely.
Tools & Tech Stack:
• Front-End: React + Next.js for the web app front-end and SSR. Next.js
offers fast development, built-in routing, and ability to scale the app eas￾ily. Use TypeScript for type safety. CSS framework or styling: utilize a
component library like Chakra UI or Material UI for pre-built responsive
components, combined with custom CSS or Tailwind for styling consis￾tency.
3
• Backend: Next.js API routes (Node.js) for backend logic, or alternatively
a Node Express/NestJS server if needed for more control. Use Node.js
for compatibility with the Chrome extension messaging and for rich npm
ecosystem (YouTube API, LLM SDKs, etc.).
• Database: PostgreSQL (e.g. via Supabase or AWS RDS) for a reliable
relational datastore. Use an ORM like Prisma for productive schema man￾agement and to ensure DB adaptability (Prisma with Next.js works well).
If using Supabase, it can handle auth and provide a pooling connection out
of the box. Consider Redis for caching layer and rate-limiting counters.
• External APIs & Services: YouTube Data API (for video details) and a
transcripts library (e.g. youtube-transcript-api in Python or similar Node
packages) to fetch captions. OpenAI API for LLM (GPT-4/GPT-3.5)
calls for summary & content generation. Perplexity API for fact-checking
(Sonar API) to retrieve live information with citations. Stripe for han￾dling subscriptions and payments. MailerSend or Resend for transactional
emails (MailerSend is developer-friendly and simple to set up). PostHog
analytics snippet for tracking.
• Infrastructure & DevOps: Cloud hosting on Vercel for the web app
for auto-scaling and CI/CD (or AWS/GCP with Docker if needed). Con￾tainerize the app using Docker to allow flexible deployment (e.g. use AWS
Fargate/ECS or Kubernetes in later stages). Set up CI pipeline (GitHub
Actions) for running tests and deploying on merge. Use GitHub for ver￾sion control with a clear branching strategy. Error monitoring via Sentry
(optional) to catch runtime errors in production.
Deliverables:
• Complete Web Application (MVP): A deployed web platform im￾plementing all MVP features: users can sign up/login, input YouTube
URLs to get summaries with timestamps, compare multiple videos, chat
with an AI assistant on video pages, generate content, and view a per￾sonal dashboard with saved items. The UI should be fully responsive and
internationalization-ready (EN/ES/PT strings).
• Pro Subscription System: A working subscription payment flow (e.g.
Stripe checkout) and enforcement of Free vs Pro limits in the app. This
includes a pricing page and upgrade flow in the UI.
• Admin Dashboard: An admin-only interface accessible by authorized
staff, with functionality to view user data, update user roles/credits, and
view basic metrics (user count, videos summarized, etc.).
• Analytics & Logging: PostHog (or Plausible) analytics configured and
verifying that key events are tracked (e.g. signups, video analyses, fea￾ture usage). Admin should be able to access these analytics dashboards.
4
Include basic server logging and monitoring setup for scalability (log ag￾gregation if on multiple servers).
• Email Notifications: Email templates (HTML/CSS) for at least: wel￾come email, password reset, usage alert, and a weekly engagement email.
Backend triggers hooked up to actually send these via MailerSend/Resend
on appropriate events. Verify email deliverability and opt-out compliance.
• Scalability Plan: Documentation or config demonstrating that the app
is containerized or can be scaled out easily (e.g. Dockerfile, or notes on
how to scale on the chosen platform). Include rate-limit configurations and
any load testing results to validate the system can handle early growth (for
example, ensure summarizing multiple videos concurrently won’t crash the
server).
• Testing: Unit and integration tests for critical backend logic (e.g. verify
that the usage limits enforce correctly, the summary parser splits times￾tamps correctly, etc.). Basic UI tests for critical flows (maybe using Cy￾press or Playwright for end-to-end test of uploading a video URL and
getting a summary).
LLM / Prompt Engineer
Responsibilities:
• AI Model Integration: Integrate Large Language Models to power
TubeWise’s AI features. Set up calls to the OpenAI API (or other LLMs)
for different tasks: summarization, Q&A, content generation. Ensure the
backend can seamlessly invoke these models with proper parameters and
error handling (timeouts, retries, etc.).
• Prompt Design & Optimization: Craft effective prompts for each AI
task to get high-quality output:
– Video Summaries: Design a prompt that takes a video transcript
and yields a structured summary with timestamps. This may involve
splitting the transcript into sections by timestamp (e.g., chunk by
time or by topic) and prompting the model to summarize each chunk,
then aggregating results. The prompt should encourage the model to
include timestamps for key points (e.g. “For each key point, prepend
the timestamp from the video”). Leverage known techniques for long
transcripts (chunk and summarize, then summarize the summaries).
– Comprehensive Comparison: For multi-URL analysis, create a
prompt workflow that compares insights from multiple videos. For
example, after getting individual summaries, use another prompt to
feed in the key points from each video and ask the LLM to highlight
differences, common insights, and unique perspectives between the
videos.
5
– Fact-Checking Assistant: Utilize Perplexity’s Sonar API for fac￾tual queries – this service combines web search with an LLM and
returns answers with citations. The prompt engineer will design how
the system uses this: e.g. when a user asks a question or highlights
a claim, format a query for Perplexity’s API and then present the
cited answer. If needed, wrap the result in additional explanation.
Ensure the assistant’s answers favor verified information and clearly
show citations.
– Content Generation: Create prompt templates to transform a
video’s summary or transcript highlights into specific content for￾mats. E.g., Twitter thread – prompt to output a series of numbered
tweets (280 characters each) summarizing the video’s key points in
an engaging way; LinkedIn post – prompt for a longer form summary
with a professional tone; Notion summary – a well-structured mark￾down with headings/bullets. Each format may require tweaking style
and tone in the prompt.
– Smart Research Briefs: For the “auto-analyze top videos on a
topic” feature, design a pipeline: given a topic, use YouTube API
to find top N relevant videos. Then automatically summarize each
(could be brief summaries if many videos), and finally have the LLM
synthesize an overall report on the topic. The prompt engineer will
script this chain of prompts: e.g., “Summarize video X. . . Summarize
video Y. . . Now compare and compile insights about [topic] from the
above videos.” Ensure coherence in the final output.
• Model Selection & Tuning: Decide on which LLMs to use for each
task by balancing quality vs cost. For the MVP, GPT-4 may be used
for the best quality summaries and complex comparisons (especially for
Pro users’ “comprehensive reviews”), while GPT-3.5-Turbo could handle
lighter tasks or free-tier requests to reduce cost. If available, experiment
with specialized models (e.g., use Google’s PaLM/Gemini for summariza￾tion as an alternative). Ensure the system is modular enough to switch
models or providers if needed (abstract the LLM calls behind an interface).
• Handling Long Transcripts: Implement strategies to handle very long
videos that exceed token limits. This could include transcript summariza￾tion in sections (recursive summarization), using embedding-based search
to find the most relevant parts of transcripts for answering specific ques￾tions, or leveraging OpenAI functions to retrieve segments by timestamp.
The engineer should also consider using OpenAI’s 16k or 32k token models
for longer inputs if available.
• Fact-Checking & Hallucination Mitigation: Beyond using Perplex￾ity, ensure the prompts instruct the model to not fabricate data. For
example, in summarizations and content generation, emphasize using the
video content only. For the Q&A, incorporate the step of retrieving from
6
Perplexity or a web source so that answers have external verification. The
prompt engineer may also add a final check step (like prompt the model
“verify if all facts above are in the transcript or cited sources”).
• Testing AI Outputs: Develop example test cases for each prompt (with
sample transcripts) to evaluate output quality. Refine prompts based on
these tests. Also, log outputs during beta usage to identify any recurring
issues (e.g., timestamps not aligning well, or the tone of generated content
needing adjustments) and iteratively improve prompts.
• Collaboration with Devs: Work closely with the full-stack developer
to implement the prompt pipelines in code (possibly using frameworks
like LangChain for orchestrating multi-step LLM calls, or writing custom
logic). Ensure that prompt templates and API keys are stored securely
(in env variables) and that the system can easily be updated with prompt
tweaks without redeploying entire application (e.g., load prompts from a
config or database).
• Future Considerations: Keep in mind future scaling – e.g., fine-tuning
a custom model on a corpus of video summaries to reduce reliance on ex￾pensive API calls, or using open-source models via frameworks like Hug￾gingFace for certain languages or offline use. While not in MVP, design
prompts in a way that can later be adapted to such models.
Tools & Tech:
• LLM Providers: Primary use of OpenAI API (GPT-4 & GPT-3.5) for
natural language generation. These are reliable for summarization and
content creation tasks. Additionally, integrate Perplexity’s API (Sonar)
for real-time Q&A with citations. Obtain API keys and ensure rate limits
(Perplexity may have its own usage quotas).
• Prompt Orchestration: Utilize libraries like LangChain or LlamaIn￾dex to manage prompt workflows, especially for the multi-step processes
(like multi-video analysis or retrieval-augmented QA). These can help with
splitting text, managing conversation state for the chat feature, and com￾bining LLM + search results.
• Data Processing: Use Python or Node scripts for preprocessing tran￾scripts (e.g., splitting into chunks by time or semantic similarity). If the
rest of backend is Node.js, consider using Python microservices for heavy
ML tasks (via Flask/FastAPI) if needed – for example, to run an open￾source summarization model or Whisper for transcription if YouTube tran￾script is unavailable.
• Vector Database (optional): Introduce a vector store (like Pinecone
or a lightweight solution via FAISS) if implementing semantic search on
transcripts. For instance, to support the chat Q&A on the video, embed
7
transcript segments with OpenAI embeddings and fetch relevant chunks
based on the user’s question, then feed those to GPT-4. This will improve
relevancy and limit token usage.
• Monitoring & Logging: Use tools like Helicone (OpenAI API proxy) or
OpenAI’s built-in logging to monitor usage of LLM calls and costs. This
helps in identifying which prompts are most expensive and optimizing
them. Also log any errors or timeouts from the AI API to quickly debug
issues.
• Versioning Prompts: Maintain prompts in a version-controlled manner
(could be in the code repo or a database). Clearly document each prompt’s
purpose and any specific formatting it requires from input data (e.g. the
expected transcript chunk length for summary prompts).
Deliverables:
• Prompt Documentation: A prompt book detailing each prompt tem￾plate used for TubeWise features, including examples of input and ex￾pected output. This serves as a spec for how the AI behaves for summaries,
comparisons, Q&A, and content generation. It should be accessible to the
whole team (for transparency and future iterations).
• Functional AI Pipelines: Fully implemented backend logic for all AI￾driven features:
– Summarization pipeline that takes a YouTube URL (or its transcript)
and returns a structured summary with timestamps.
– Multi-video comparison pipeline that yields a comparative summary
or report.
– Fact-check Q&A function that takes a query (and optional context
from a video) and returns an answer with citations (via Perplexity
or similar).
– Content generator functions for each format (Twitter, LinkedIn, No￾tion) that output properly formatted text ready to copy or publish.
• Quality Benchmarks: A set of evaluated results on a few sample videos
(covering different domains like a lecture, a how-to, a news clip) to demon￾strate the quality of summaries and generated content. This might include
the output and a brief analysis of correctness/clarity. It will serve as a
baseline to improve upon.
• Adjusted Model Settings: The configuration for the LLM calls (e.g.,
temperature, max tokens) optimized for each task (e.g., perhaps lower
temperature for factual Q&A, higher for creative re-writing in a social
media style). These settings should be tuned and documented.
8
• Failover Strategy: A brief plan or implementation notes on what hap￾pens if the LLM API fails or returns an error (e.g., the system returns a
friendly error message or a partial result to the user, and logs the event).
Possibly include a basic fallback for summaries (maybe a simpler extrac￾tive summary from transcript as a worst-case).
• Collaboration Outputs: The prompt engineer should have contributed
to the code or provided scripts for any custom AI integration (like a Python
script for transcript processing if needed). All such code should be deliv￾ered and integrated into the repo. Additionally, any environment setup
needed (like ensuring API keys, vector DB if used) should be clearly com￾municated for deployment.
Product Designer (UX/UI)
Responsibilities:
• User Experience Design: Own the UX flow of TubeWise across web
and extension. Map out the user journey from landing on the site, signing
up, using the video analysis features, to upgrading to Pro. Ensure the
interface is intuitive for both casual users (free tier) and power users (Pro
features). Key flows: inputting a YouTube link and viewing the summary
results, comparing videos (adding multiple links), using the chat assistant
on a video page, saving highlights to the dashboard, and exporting content
to other platforms.
• UI Design & Prototyping: Create high-fidelity designs for all screens
of the web app and the Chrome extension. This includes:
– Landing/Marketing Pages: Design a compelling homepage that
clearly explains TubeWise’s value (with visuals for features like the
summary and chat overlay). Include pricing section comparing Free
vs Pro, and a clear call-to-action to sign up.
– Main App Interface: Design the page where users input a video
URL and see results. The summary should be easy to read with
timestamps (perhaps as clickable links or a timeline UI). Ensure the
video player or thumbnail is present alongside the summary for con￾text. For multi-URL analysis, design a layout that can show multiple
summaries side by side or a combined report – possibly using cards
or a comparison table style.
– Chat/Sidebar (Extension UI): Design the sidebar that appears
on YouTube when the extension is active. It should feel like a natural
extension of YouTube’s UI (using appropriate spacing and theming).
The sidebar will contain tabs or sections for: summary overview, full
transcript with scroll and highlight, and a chat interface for Q&A.
Ensure the chat UI allows the user to type questions and see answers
with citations (perhaps source links).
9
– Content Generation Output: Design modal or output screens for
the generated content. For example, when a user requests a Twitter
thread, show the thread as a series of tweet bubbles or a formatted
list. For a Notion summary, present it in a clean markdown preview
style. Include clear options to copy the content or export (maybe even
integration buttons like “Share to Twitter” as a future enhancement).
– Personal Dashboard: Create the dashboard design where users see
their history: list of videos analyzed (with thumbnails), any saved
highlights or notes, and categories/tags. Possibly include a search
or filter by topic. This page should also have an obvious “Upgrade
to Pro” section for free users, showing usage stats (e.g., “3/5 free
analyses used”). For Pro users, show their remaining “comprehensive
reviews” count (10 per month reset) and maybe an account status.
– Admin Interfaces: While not customer-facing, design simple and
functional admin pages if needed (list of users, usage metrics graphs).
These can reuse a UI kit or default admin theme to save time.
– Responsive Layouts: Adapt designs for mobile and tablet. On
mobile, the video summary might stack vertically (video player or
thumbnail on top, summary below). The extension’s functionality
on mobile will likely be via the web app (since Chrome extensions
don’t work on mobile YouTube), so ensure the web app is fully usable
on a mobile browser as an alternative (e.g., user can paste a link and
get summary on phone).
• Design System & Branding: Develop a cohesive visual style – choose
a color scheme (perhaps something aligning with YouTube’s palette for
familiarity, but distinct to brand TubeWise), typography (web-safe or
Google fonts that are professional and readable), and iconography. Create
a small design system with components (buttons, modals, cards, etc.)
to ensure consistency. Provide a logo and favicon for TubeWise if not
already existing, and graphics for the Chrome Web Store listing (for the
extension).
• Internationalization in Design: Account for different languages in the
UI layouts. For instance, ensure that buttons and menu have enough space
for potentially longer text in Spanish/Portuguese. Avoid hard-coding text
in images. Plan a language switcher UI element if needed (a dropdown
or icon). Provide designs for each supported language’s landing page text
(the team can get translations, but the designer should show how it will
look).
• Pro vs Free UX: Deliberately design how Pro features are indicated.
E.g., if a free user tries to access a Pro-only feature (like multi-video
comparison or exporting to Notion), show a modal or upgrade prompt
with the pricing info. The UX should encourage upgrading without being
10
too obtrusive. Possibly incorporate subtle reminders (like a badge on
certain buttons saying “Pro”).
• Usability Testing & Iteration: Before finalizing, conduct or simulate
basic usability tests on the prototype (could be informal, with team mem￾bers or a few potential users) to gather feedback on the workflow. Adjust
the design based on feedback to reduce any confusion. For example, en￾sure it’s clear how to install/use the Chrome extension from the web app,
or how to add a second video for comparison.
• Collaboration & Handoff: Work closely with developers to ensure de￾signs are implementable. Provide design specs, CSS guidelines, and re￾sponsive behavior notes. Use tools like Figma’s handoff features or Zeplin
to generate style guides. Remain available during development to clarify
requirements and possibly adjust designs if technical constraints arise.
Tools & Resources:
• Design Software: Figma for all UI/UX design work – create interactive
prototypes that simulate the TubeWise flows. Figma allows collaboration,
so the team can comment and review within the design files. Use Figma’s
component features to build a design system (buttons, inputs, modals).
• Graphic/Branding Tools: Adobe Illustrator or Canva for logo design
and any custom graphics (like icons illustrating features on the landing
page). Ensure the logo scales well (for app icon, extension icon, etc.) and
has variants (light/dark backgrounds).
• Collaboration: Use Figma’s commenting and versioning to iterate with
team input. Possibly use Notion to gather requirements or describe user
personas and user stories that guide the design. Share prototypes with
stakeholders for feedback early.
• UI Framework Guidance: While the designer is not coding, familiarity
with the front-end framework (React + possibly a UI library like Material
UI) is useful. Possibly choose a Material Design inspired approach if us￾ing Material UI components – this could speed up dev, as many standard
components (tabs, dialogs, lists) exist. Alternatively, lean into a mini￾malist custom design that can be implemented with Tailwind CSS utility
classes – coordinate with devs on what they prefer to ensure design-to-code
translation is smooth.
• Accessibility Checker: Use Figma plugins or manual review to ensure
color contrast is sufficient for readability. Plan for basic accessibility: all
interactive elements should be large enough on mobile, consider screen￾reader order of content in design, etc., so the developers can implement
those standards.
11
Deliverables:
• Complete Figma Prototype: A multi-page Figma file (or project) con￾taining:
– All high-fidelity screens for web (desktop and mobile views).
– Chrome extension sidebar and popup UI designs.
– Interactive prototype links demonstrating key flows (e.g., clicking
“Summarize” button shows a loading state then a summary view,
clicking “Compare videos” allows adding another link, etc.).
• Style Guide: Documentation of the design system – including color
palette (with hex codes), font styles (with sizes, weights for headings,
body text), and example components (button states, form fields, etc.).
This can be a Figma page or exported PDF that developers can refer to.
Also specify spacing and layout grids used for consistency.
• Assets Export: All necessary image assets (logo in various resolutions,
icons, any illustrations) exported in web-friendly formats (SVG/PNG).
Include an icon set for the extension (icon.png in required sizes as per
Chrome store guidelines).
• Design Specs for Developers: For each key page, provide a spec detail￾ing margins, sizes, and behaviors if not obvious. (Figma’s inspect mode
largely covers this, but complex interactions should be described in a sep￾arate document or Notion page for clarity.)
• User Flow Diagrams: (Optional but useful) Diagrams or flowcharts
showing the user navigation map – e.g., from Dashboard user can go to
a new analysis, or from extension sidebar user can save a highlight to
dashboard, etc. This helps ensure no use-case is missed by developers.
• Usability Test Report: (If conducted) A brief summary of any usability
testing findings and the changes made as a result. This shows that the
design has been validated in some form. Even if informal, note things like
“Users struggled to find how to start the comparison – added a clearer ‘+
Add another video’ button”.
• Continuous Support: Agreement that the designer will be available
during development sprints to quickly provide any missing states or new
icons that are discovered to be needed (for example, an error state for
when a video can’t be summarized).
Chrome Extension Developer
Responsibilities:
• Chrome Extension Architecture: Build the TubeWise Chrome exten￾sion from the ground up, following Chrome Extension Manifest v3 guide￾lines. Set up the extension structure with a content script (injected into
12
YouTube pages to add our UI), a background script (for persistent tasks
or messaging), and possibly an options page or popup if needed (e.g., for
login or settings).
• Sidebar & Overlay Implementation: Develop the sidebar interface
on YouTube that the Product Designer specified. This involves inject￾ing a sidebar HTML/CSS into the YouTube watch page. The sidebar
should toggle open/closed (perhaps via a TubeWise button inserted near
the YouTube player). In this sidebar, implement:
– Summary View: Display the summary of the current video with
clickable timestamps. Implement clicking a timestamp to seek the
YouTube video to that time (use YouTube’s player API or postMes￾sage to the player).
– Transcript & Highlighting: Optionally, show the full transcript
in a scrollable area (which can be obtained via YouTube’s API or our
backend). Allow user to highlight text and right-click or button to
“Ask” about that segment.
– Chat Interface: A text input where users can ask questions about
the video. The extension should capture the question, send it along
with context (video ID, maybe selected transcript text) to TubeWise
backend, then display the answer in the sidebar with sources (links
clickable).
• Communication with Backend: Implement secure communication be￾tween the extension and the TubeWise web backend. Likely use HTTPS
fetch calls from the content script or background script to TubeWise API
endpoints (for summary retrieval, Q&A, etc.). Attach the user’s auth to￾ken to these requests. Ensure CORS is configured on the backend to allow
these requests from extension context.
• Authentication Flow: Allow the user to log into their TubeWise ac￾count via the extension. E.g., the first time the user activates the exten￾sion, if not logged in, prompt for login. This could be done by open￾ing a small extension popup or redirecting to the TubeWise web app
login and then receiving the auth token. Use Chrome’s secure storage
(chrome.storage) to keep the auth token. The extension developer coor￾dinates with the full-stack dev to possibly provide an OAuth flow or an
API key for the extension. Alternative: Since the extension and web app
share the same domain (if web app is hosted, say, at tubewise.com), the
extension could detect if the user is logged in to the site (via cookie) and
use that session.
• Performance & Compliance: Ensure the extension does not signifi￾cantly slow down YouTube page load. Use efficient DOM manipulation
(possibly a lightweight framework or plain JS for the sidebar). The con￾tent script should defer heavy work until the user clicks the extension or
13
the video is loaded. Adhere to Chrome Store policies: request only needed
permissions (probably just access to youtube.com/*, maybe storage, and
activeTab). Include a concise privacy policy (the extension likely will state
it sends video data to TubeWise servers for analysis).
• Transcript Control Feature: Implement controls to navigate the video
via transcript. E.g., maybe a feature where hovering over a sentence
in summary/transcript highlights that segment on the video timeline, or
clicking jumps to it. Also possibly a “AI chaptering” feature: using the
summary’s timestamps, render them as chapters that the user can click
to skip sections.
• Local vs Cloud Processing: Most heavy lifting will be done by the
backend (LLM, etc.), but consider if any functionality can be offline. For
instance, for very quick summaries, maybe a local summary of descriptions
or captions if the user is offline (out of scope for MVP perhaps). In general,
keep extension logic simple and delegate to backend.
• Multi-Video Comparison via Extension: If the user wants to com￾pare videos, the extension developer could add a way to queue videos for
comparison (like a “+ Compare this video” button in the extension UI
that sends the video ID to the web app’s comparison queue). However,
this might be complex to do purely in extension. Simpler: direct the user
to the web app’s comparison page with the URLs pre-filled (the extension
can open a new tab pointing to tubewise.com/compare?vid1=...vid2=...
if two videos are selected). Coordinate with web app to handle such deep
links.
• Testing on Browsers: Test the extension on Chrome, and prepare for
compatibility with Edge (which uses Chromium extensions) and possi￾bly Firefox (which might need minor adjustments to manifest). Ensure
that the UI behaves with YouTube’s different themes (light/dark mode)
– perhaps offer a toggle to match it.
• Updates & Error Handling: Set up the extension to handle scenarios
like the backend being unreachable (show a friendly message in the sidebar
if TubeWise API is down or if the user is offline). Also handle if a video
has no transcript available – prompt that summarization might be lim￾ited. Use Chrome’s runtime messaging if needed for complex coordination
between scripts. Prepare the extension for publishing by incrementing
versions and writing a brief changelog for the Chrome Web Store listing.
Tools & Tech:
• Languages: TypeScript or JavaScript for extension development. Type￾Script is preferred to maintain code quality and catch errors early, espe￾cially as the extension interacts with external APIs.
14
• Frameworks: Because the extension UI could be moderately complex,
using a lightweight framework like Preact or Svelte for the sidebar could
be helpful (they have smaller bundle sizes). Alternatively, use plain JS
with templating or simple jQuery for quicker implementation – but en￾sure maintainability. If using React/Preact, set up a build pipeline (Web￾pack/Vite) to bundle the content script and styles.
• Build & Bundling: Use Webpack or Vite configured for Chrome ex￾tension output (there are boilerplate projects for Chrome extension +
React/TS setup). This will compile code and assets into the required
format under a dist folder ready for packaging.
• Chrome APIs: Use Chrome Extension APIs such as chrome.runtime.onInstalled
(to maybe open a welcome page or guide), chrome.storage for storing auth
tokens or user preferences, and chrome.tabs if needed to communicate be￾tween the extension popup and content script. If implementing an exten￾sion browser action (icon click opens a popup), use that for quick actions
like summarizing the current video or going to the TubeWise site.
• Testing & Debugging: Use Chrome’s Extension debugging tools to
test content scripts on YouTube. Also, test edge cases (e.g., user quickly
switching videos or navigating to a non-YouTube page where extension
should do nothing).
• Version Control: Keep the extension code in the same repo (or a sub￾repo) as the main app for coherence, or a separate repository if desired.
Use proper semantic versioning for releases.
• Security: Follow best practices, e.g., don’t expose secret API keys in the
extension code (all sensitive calls should go to backend which holds keys).
Use HTTPS for all fetches. Also, validate inputs from the content script
on the backend side as well (never fully trust extension input, though it’s
our own app).
Deliverables:
• Chrome Extension Package: A ready-to-publish extension (ZIP or
Chrome Web Store submission) including the manifest, compiled scripts,
and assets. It should be tested and working on the latest Chrome. The
manifest will list required permissions (likely ”https://www.youtube.com/*”,
”https://api.tubewise.com/*” etc., and possibly ”storage”).
• Extension Source Code: Well-documented source in the repository.
Include README for how to build and load the extension unpacked for
development. Also instructions for publishing updates.
• Functional Sidebar: The extension sidebar on YouTube that can display
summaries and accept questions. This should be demonstrated with the
15
backend: e.g., when a video is loaded, user clicks “Summarize” in the
extension, it calls the API, then populates the sidebar with the summary
and a list of timestamps. The developer should deliver this fully integrated
with the live backend or a staging server.
• Login Flow Integration: Ability for a user to authenticate. Likely
delivered as a small login page or a redirect mechanism. This should be
tested: e.g., if a user isn’t logged in and tries to use the extension, it
prompts them to log in (perhaps open TubeWise login page), after which
the extension recognizes the login (maybe via receiving an auth token from
a redirect callback or the user pasting an API key). The exact method
and its seamlessness should be demonstrated.
• Documentation: A short guide (for internal use) on how the extension’s
code is structured and how it communicates with the backend. Also,
any limitations or things to watch for (for example, “YouTube frequently
changes their DOM, so the selector for inserting the sidebar might need
updating if YouTube’s layout changes – here’s what to adjust”).
• Compatibility Confirmation: Note which browsers the extension has
been tested on (Chrome, Edge). If planning a Firefox version, mention
any changes needed (e.g., Firefox might not support Manifest v3 yet, or
uses a slightly different manifest keys). Possibly prepare a Firefox add-on
manifest if time permits.
• Chrome Web Store Listing Materials: Work with the marketer to
prepare description, screenshots, and an icon for the extension listing. The
developer should supply functional screenshots (e.g., a screenshot of the
TubeWise sidebar on a YouTube video page showing a summary) as these
will be needed for the store.



فقط قسمت ai قضیه به شکل multiagent باشه، یا با کتابخونه crew ai یا با langgraph، هرکدوم راحت ترن
واسه backend همون fast api اوکیه اگه راحت ترن باهاش. نیازی به nodejs و اینا نیست

در مورد قسمت ai اگه ممکنه

Multiagent باشه لطفا، حالا کتابخونش crew ai باشه یا langgrapgh چندان فرقی نداره، هرکدوم که راحت ترن

تو این داکیومنت یه قسمتی خوب واضح نشده، میخوام قابلیت این و داشته باشه وقتی یوزر تو چت مربوط به یه ویدئو میگه “ کدوم قسمت ویدئو درباره انسولین حرف میزنه” براش تایم لاین هایی که در مورد انسولین صحبت میشه بیاد به صورت گزینه های قابل کلیک و بتونه کلیک کنه رو هرکدوم و ویدئوش بره رو اون قسمت
